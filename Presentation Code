## Command Line code:




## Maze Creation and Formating ------------------------------------


## Maze Solution Formatting --------------------------------
import matplotlib.pyplot as plt

x=[400, 380, 360, 360, 340, 340, 340, 340, 320, 300, 300, 320, 320, 300, 280, 280, 280, 280, 260, 240, 240, 240, 240, 220, 220, 220, 220, 200, 200, 180, 180, 180, 200, 220, 220, 200, 200, 220, 220, 240, 240, 260, 260, 280, 280, 260, 240, 240, 220, 200, 200, 180, 180, 180, 160, 160, 160, 140, 120, 100, 100, 100, 80, 80, 60, 60, 80, 80, 80, 80, 100, 100, 120, 120, 100, 100, 100, 120, 120, 120, 140, 140, 140, 140, 160, 160, 140, 140, 140, 140, 140, 120, 100, 100, 80, 60, 60, 60, 60, 40, 20, 20, 40, 40, 20, 20, 20, 40, 40, 60, 60, 80, 80, 80, 60, 40, 20, 20, 40, 40, 40, 60, 60, 80, 80, 80, 80, 60, 60, 40, 20, 20, 20, 40, 40, 20]
y=[380, 380, 380, 400, 400, 380, 360, 340, 340, 340, 360, 360, 380, 380, 380, 360, 340, 320, 320, 320, 340, 360, 380, 380, 360, 340, 320, 320, 340, 340, 320, 300, 300, 300, 280, 280, 260, 260, 240, 240, 260, 260, 240, 240, 220, 220, 220, 200, 200, 200, 220, 220, 240, 260, 260, 240, 220, 220, 220, 220, 240, 260, 260, 280, 280, 300, 300, 320, 340, 360, 360, 340, 340, 320, 320, 300, 280, 280, 260, 240, 240, 260, 280, 300, 300, 320, 320, 340, 360, 380, 400, 400, 400, 380, 380, 380, 360, 340, 320, 320, 320, 300, 300, 280, 280, 260, 240, 240, 220, 220, 240, 240, 220, 200, 200, 200, 200, 180, 180, 160, 140, 140, 120, 120, 100, 80, 60, 60, 80, 80, 80, 60, 40, 40, 20, 20]
x2=[380, 360, 340, 320, 300, 300, 280, 280, 260, 240, 220, 220, 240, 260, 260, 240, 220, 200, 180, 180, 180, 200, 200, 180, 180, 200, 220, 220, 240, 240, 240, 260, 280, 300, 300, 320, 340, 340, 340, 340, 360, 380, 380, 380, 360, 360, 380, 400, 400, 400, 380, 380, 360, 360, 360, 360, 380, 380, 400, 400, 400, 380, 380, 360, 360, 340, 320, 300, 300, 280, 260, 260, 280, 280, 280, 260, 240, 240, 220, 220, 240, 240, 240, 260, 260, 240, 240, 220, 200, 200, 200, 200, 180, 180, 160, 140, 140, 140, 160, 160, 180, 180, 160, 140, 120, 100, 80, 60, 60, 80, 80, 80, 100, 120, 120, 120, 140, 160, 180, 180, 160, 140, 140, 120, 120, 100, 80, 80, 80, 60, 60, 60, 40, 40, 20, 20]
y2=[400, 400, 400, 400, 400, 380, 380, 360, 360, 360, 360, 380, 380, 380, 400, 400, 400, 400, 400, 380, 360, 360, 340, 340, 320, 320, 320, 300, 300, 320, 340, 340, 340, 340, 320, 320, 320, 340, 360, 380, 380, 380, 360, 340, 340, 320, 320, 320, 300, 280, 280, 300, 300, 280, 260, 240, 240, 260, 260, 240, 220, 220, 200, 200, 220, 220, 220, 220, 200, 200, 200, 220, 220, 240, 260, 260, 260, 240, 240, 220, 220, 200, 180, 180, 160, 160, 140, 140, 140, 120, 100, 80, 80, 100, 100, 100, 80, 60, 60, 40, 40, 20, 20, 20, 20, 20, 20, 20, 40, 40, 60, 80, 80, 80, 100, 120, 120, 120, 120, 140, 140, 140, 160, 160, 140, 140, 140, 120, 100, 100, 80, 60, 60, 40, 40, 20]

y_flipped=[]
scaled_y=[]
scaled_x=[]
points=[]
for i in y:
    y_flipped.append(abs(i-400))
reversed_y=y_flipped[::-1]
reversed_x=x[::-1]
for index, value in enumerate(reversed_y):
    scaled_y.append(value/40+1)
    scaled_x.append(reversed_x[index]/40+0.5)
for i in range(len(scaled_x)):
    points.append([scaled_x[i],scaled_y[i]])

y_flipped2=[]
scaled_y2=[]
scaled_x2=[]
points2=[]
for i in y2:
    y_flipped2.append(abs(i-400))
reversed_y2=y_flipped2[::-1]
reversed_x2=x2[::-1]
for index, value in enumerate(reversed_y2):
    scaled_y2.append(value/40+1)
    scaled_x2.append(reversed_x2[index]/40+0.5)
for i in range(len(scaled_x2)):
    points2.append([scaled_x2[i],scaled_y2[i]])

## Turtlesim -----------------------------------------------
#!/usr/bin/env python3
import rospy
from turtlesim.msg import Pose
from geometry_msgs.msg import Twist
from turtlesim.srv import TeleportAbsolute
from turtlesim.srv import Spawn
from std_srvs.srv import Empty as EmptyServiceCall
from turtlesim.srv import SetPen
 
pi=3.1415926535897
turtle_x=1
turtle_y=10.5##will need to change based off of first point
turtle_angle=0
desired_angle=0
spawn_theta=-pi/2
dist_travled=0
iterable=0
 
def set_position():
   global spawn_theta
   rospy.wait_for_service("/turtle1/teleport_absolute")
   Initial= rospy.ServiceProxy("/turtle1/teleport_absolute",TeleportAbsolute)
   Initial(1,10.5,spawn_theta)
 
def spawning():
   global spawn_theta
   rospy.wait_for_service('spawn')
   spawn_t2 = rospy.ServiceProxy('spawn', Spawn)
   spawn_t2(1,10.5,0,'turtle2')
 
def call_set_pen_service(r,g,b,width,off):
   try:
       set_pen = rospy.ServiceProxy('/turtle1/set_pen',SetPen)
       response = set_pen(r,g,b,width,off)
   except rospy.ServiceException as e:
       rospy.logwarn(e)
 
def path(points):
   global pi
   global spawn_theta
   global iterable
   x=[]
   y=[]
   x_distance_between=[]
   y_distance_between=[]
   dist=[]
   turn=[]
 
   for i in points:
       x.append(i[0])
       y.append(i[1])
   for i in range(2):## change the spawn angle based off of this
       if i==0:
           pass
       else:
           if x[i]>x[i-1] and y[i]==y[i-1]:
               theta=0
               spawn_theta=0
           elif x[i]<x[i-1] and y[i]==y[i-1]:
               theta=180
               spawn_theta=pi
           elif y[i]>y[i-1] and x[i]==x[i-1]:
               theta=90
               spawn_theta=pi/2
           elif y[i]<y[i-1] and x[i]==x[i-1]:
               theta=270
               spawn_theta=-pi/2
   for index in range(len(x)):
       if index>0:
           x_distance_between.append(x[index]-x[index-1])
           y_distance_between.append(y[index]-y[index-1])
   for i in range(len(points)):
       if i == 0:
           pass
       else:
           if theta == 0:
               if y[i]-y[i-1] == 0:
                   turn.append('None')
               elif x[i]-x[i-1] == 0:
                   if y[i]>y[i-1]:
                       turn.append('Left')
                       theta=90
                   elif y[i]<y[i-1]:
                       turn.append('Right')
                       theta=270
           elif theta == 90:
               if x[i]-x[i-1] == 0:
                   turn.append('None')
               else:
                   if x[i]>x[i-1]:
                       turn.append('Right')
                       theta=0
                   elif x[i]<x[i-1]:
                       turn.append('Left')
                       theta=180
           elif theta == 180:
               if y[i]-y[i-1] == 0:
                   turn.append('None')
               else:
                   if y[i]<y[i-1]:
                       turn.append('Left')
                       theta=270
                   elif y[i]>y[i-1]:
                       turn.append('Right')
                       theta=90
           elif theta == 270:
               if x[i]-x[i-1] == 0:
                   turn.append('None')
               else:
                   if x[i]>x[i-1]:
                       turn.append('Left')
                       theta=0
                   elif x[i]<x[i-1]:
                       turn.append('Right')
                       theta=180
   newlist=[]
   for i in range(len(x_distance_between)):
       newlist.append([turn[i],x_distance_between[i],y_distance_between[i]])
   return newlist
 
def pose_callback(pose: Pose):
   global turtle_x
   global turtle_y
   global turtle_angle
   turtle_x=pose.x
   turtle_y=pose.y
   turtle_angle=pose.theta
 
def rotate(turn):
   global turtle_angle
   vel=Twist()
   speed=45## change back to 20 and compare with other values
   angle=90
   if turn == 'None':
       pass
   elif turn == 'Left':
       angular_speed=speed*2*pi/360
       vel.angular.z=angular_speed
       if turtle_angle == 0:
           desired_angle=pi/2
       elif turtle_angle < 0.78 and turtle_angle > -0.78:
           desired_angle=pi/2
       elif turtle_angle < 2.35 and turtle_angle > 0.78:
           desired_angle=pi
       elif turtle_angle < -2.35 or turtle_angle > 2.35:
           desired_angle=-pi/2
       elif turtle_angle < 0 or turtle_angle > -2.35:
           desired_angle=0
 
       if desired_angle==pi/2:
           while turtle_angle<desired_angle:
               pub.publish(vel)
       elif desired_angle==pi:
           while turtle_angle<desired_angle:
               if turtle_angle<0:
                   break
 
               pub.publish(vel)
       elif desired_angle==-pi/2:
           while turtle_angle>0:
               pub.publish(vel)
           while turtle_angle<desired_angle:
               pub.publish(vel)
       elif desired_angle==0:
           while turtle_angle<desired_angle:
               pub.publish(vel)
   elif turn == 'Right':
       angular_speed=speed*2*pi/360
       vel.angular.z=-angular_speed
       if turtle_angle == 0:
           desired_angle=-pi/2
       elif turtle_angle < 0.78 and turtle_angle > -0.78:
           desired_angle=-pi/2
       elif turtle_angle > -2.35 and turtle_angle < -0.78:
           desired_angle=-pi
       elif turtle_angle < -2.35 or turtle_angle > 2.35:
           desired_angle=pi/2
       elif turtle_angle > 0 and turtle_angle < 2.35:
           desired_angle=0.0
 
       if desired_angle == -pi/2:
           while turtle_angle>desired_angle:
               pub.publish(vel)
       elif desired_angle == -pi:
           while turtle_angle>desired_angle:
               if turtle_angle>0:
                   break
               pub.publish(vel)
       elif desired_angle == pi/2:
           while turtle_angle<0:
               pub.publish(vel)
           while turtle_angle>desired_angle:
               pub.publish(vel)
       elif desired_angle == 0:
           while turtle_angle>desired_angle:
               pub.publish(vel)
   vel.angular.z=0
   pub.publish(vel)
  
def forward(dist_x,dist_y):
   global turtle_x
   global turtle_y
   global turtle_angle
   global dist_travled
   global iterable
 
   lin_vel=Twist()
   lin_vel.linear.x=2.0 ## change back to 2.0 and compare with other values
   destiation_x=dist_x+turtle_x
   destiation_y=dist_y+turtle_y
   dist_travled=dist_x+dist_y
 
   if (turtle_angle < 0.78 and turtle_angle > -0.78) or (turtle_angle>2.35 or turtle_angle<-2.35):
       if dist_x>0:
           while turtle_x<destiation_x:
               pub.publish(lin_vel)
           lin_vel.linear.x=0
           pub.publish(lin_vel)
       elif dist_x<0:
           while turtle_x>destiation_x:
               pub.publish(lin_vel)
           lin_vel.linear.x=0
           pub.publish(lin_vel)
   elif (turtle_angle>0.78 and turtle_angle<2.35) or (turtle_angle<-0.78 and turtle_angle>-2.35):
       if dist_y>0:
           while turtle_y<destiation_y:
               pub.publish(lin_vel)
           lin_vel.linear.x=0
           pub.publish(lin_vel)
       elif dist_y<0:
           while turtle_y>destiation_y:
               pub.publish(lin_vel)
           lin_vel.linear.x=0
           pub.publish(lin_vel)
 
def move(turn,dist_x,dist_y):
   rotate(turn)
   forward(dist_x,dist_y)
      
if __name__ == '__main__':
   rospy.init_node("turtle_controller",anonymous=True)
   while not rospy.is_shutdown():
       pub = rospy.Publisher('/turtle1/cmd_vel',Twist,queue_size=10)
       sub = rospy.Subscriber('/turtle1/pose',Pose,callback=pose_callback)
      
       rospy.loginfo('Node started')
      
       set_position()
 
       # clearing the background after initialization
       rospy.wait_for_service('clear')
       clear_background = rospy.ServiceProxy('clear', EmptyServiceCall)
       clear_background()
      
       rospy.wait_for_service('/turtle1/set_pen')
       call_set_pen_service(255,0,0,3,0)
 
       t0=rospy.Time.now().to_sec()
       x=[380, 360, 340, 320, 300, 300, 280, 280, 260, 240, 220, 220, 240, 260, 260, 240, 220, 200, 180, 180, 180, 200, 200, 180, 180, 200, 220, 220, 240, 240, 240, 260, 280, 300, 300, 320, 340, 340, 340, 340, 360, 380, 380, 380, 360, 360, 380, 400, 400, 400, 380, 380, 360, 360, 360, 360, 380, 380, 400, 400, 400, 380, 380, 360, 360, 340, 320, 300, 300, 280, 260, 260, 280, 280, 280, 260, 240, 240, 220, 220, 240, 240, 240, 260, 260, 240, 240, 220, 200, 200, 200, 200, 180, 180, 160, 140, 140, 140, 160, 160, 180, 180, 160, 140, 120, 100, 80, 60, 60, 80, 80, 80, 100, 120, 120, 120, 140, 160, 180, 180, 160, 140, 140, 120, 120, 100, 80, 80, 80, 60, 60, 60, 40, 40, 20, 20]
       y=[400, 400, 400, 400, 400, 380, 380, 360, 360, 360, 360, 380, 380, 380, 400, 400, 400, 400, 400, 380, 360, 360, 340, 340, 320, 320, 320, 300, 300, 320, 340, 340, 340, 340, 320, 320, 320, 340, 360, 380, 380, 380, 360, 340, 340, 320, 320, 320, 300, 280, 280, 300, 300, 280, 260, 240, 240, 260, 260, 240, 220, 220, 200, 200, 220, 220, 220, 220, 200, 200, 200, 220, 220, 240, 260, 260, 260, 240, 240, 220, 220, 200, 180, 180, 160, 160, 140, 140, 140, 120, 100, 80, 80, 100, 100, 100, 80, 60, 60, 40, 40, 20, 20, 20, 20, 20, 20, 20, 40, 40, 60, 80, 80, 80, 100, 120, 120, 120, 120, 140, 140, 140, 160, 160, 140, 140, 140, 120, 100, 100, 80, 60, 60, 40, 40, 20]
       y_flipped=[]
       for i in y:
           y_flipped.append(abs(i-400))
       reversed_y=y_flipped[::-1]
       reversed_x=x[::-1]
 
       scaled_y=[]
       scaled_x=[]
       for index, value in enumerate(reversed_y):
           scaled_y.append(value/40+1)
           scaled_x.append(reversed_x[index]/40+0.5)
 
       points=[]
       for i in range(len(scaled_x)):
           points.append([scaled_x[i],scaled_y[i]])
 
       path_list1 = path(points)
       for i in path_list1:
           move(i[0],i[1],i[2])
       t1=rospy.Time.now().to_sec()
       duration = t1 - t0
       rospy.loginfo('First Maze')
       rospy.loginfo("Distance traveled: %s meters",dist_travled)
       rospy.loginfo("Time it took to travel: %s seconds",duration)
       break
##Gazebo ----------------------------------------


#!/usr/bin/env python

import rospy
from geometry_msgs.msg import Twist, Point, Quaternion
import tf
from math import radians, copysign, sqrt, pow, pi, atan2
from tf.transformations import euler_from_quaternion
import numpy as np



class GotoPoint():
    def __init__(self,goal_x,goal_y,goal_z):
        rospy.init_node('turtlebot3_pointop_key', anonymous=False)
        rospy.on_shutdown(self.shutdown)
        self.cmd_vel = rospy.Publisher('cmd_vel', Twist, queue_size=5)
        position = Point()
        move_cmd = Twist()
        r = rospy.Rate(10)
        self.tf_listener = tf.TransformListener()
        self.odom_frame = 'odom'
        self.goal_x =float(goal_x)
        self.goal_y = float(goal_y)
        self.goal_z = float(goal_z)

        try:
            self.tf_listener.waitForTransform(self.odom_frame, 'base_footprint', rospy.Time(), rospy.Duration(1.0))
            self.base_frame = 'base_footprint'
        except (tf.Exception, tf.ConnectivityException, tf.LookupException):
            try:
                self.tf_listener.waitForTransform(self.odom_frame, 'base_link', rospy.Time(), rospy.Duration(1.0))
                self.base_frame = 'base_link'
            except (tf.Exception, tf.ConnectivityException, tf.LookupException):
                rospy.loginfo("Cannot find transform between odom and base_link or base_footprint")
                rospy.signal_shutdown("tf Exception")

        (position, rotation) = self.get_odom()
        last_rotation = 0
        linear_speed = 1
        angular_speed = 1
        
        if self.goal_z > 180 or self.goal_z < -180:
            print("you input wrong z range.")
            self.shutdown()
        self.goal_z = np.deg2rad(self.goal_z)
        goal_distance = sqrt(pow(self.goal_x - position.x, 2) + pow(self.goal_y - position.y, 2))
        distance = goal_distance

        while distance > 0.05:
            (position, rotation) = self.get_odom()
            x_start = position.x
            y_start = position.y
            path_angle = atan2(self.goal_y - y_start, self.goal_x- x_start)

            if path_angle < -pi/4 or path_angle > pi/4:
                if self.goal_y < 0 and y_start < self.goal_y:
                    path_angle = -2*pi + path_angle
                elif self.goal_y >= 0 and y_start > self.goal_y:
                    path_angle = 2*pi + path_angle
            if last_rotation > pi-0.1 and rotation <= 0:
                rotation = 2*pi + rotation
            elif last_rotation < -pi+0.1 and rotation > 0:
                rotation = -2*pi + rotation
            move_cmd.angular.z = angular_speed * path_angle-rotation

            distance = sqrt(pow((self.goal_x - x_start), 2) + pow((self.goal_y - y_start), 2))
            move_cmd.linear.x = min(linear_speed * distance, 0.1)

            if move_cmd.angular.z > 0:
                move_cmd.angular.z = min(move_cmd.angular.z, 1.5)
            else:
                move_cmd.angular.z = max(move_cmd.angular.z, -1.5)

            last_rotation = rotation
            self.cmd_vel.publish(move_cmd)
            r.sleep()
        (position, rotation) = self.get_odom()

        while abs(rotation - self.goal_z) > 0.05:
            (position, rotation) = self.get_odom()
            if self.goal_z >= 0:
                if rotation <= self.goal_z and rotation >= self.goal_z - pi:
                    move_cmd.linear.x = 0.00
                    move_cmd.angular.z = 0.5
                else:
                    move_cmd.linear.x = 0.00
                    move_cmd.angular.z = -0.5
            else:
                if rotation <= self.goal_z + pi and rotation > self.goal_z:
                    move_cmd.linear.x = 0.00
                    move_cmd.angular.z = -0.5
                else:
                    move_cmd.linear.x = 0.00
                    move_cmd.angular.z = 0.5
            self.cmd_vel.publish(move_cmd)
            r.sleep()


        rospy.loginfo("Stopping the robot...")
        self.cmd_vel.publish(Twist())


    def get_odom(self):
        try:
            (trans, rot) = self.tf_listener.lookupTransform(self.odom_frame, self.base_frame, rospy.Time(0))
            rotation = euler_from_quaternion(rot)

        except (tf.Exception, tf.ConnectivityException, tf.LookupException):
            rospy.loginfo("TF Exception")
            return

        return (Point(*trans), rotation[2])


    def shutdown(self):
        self.cmd_vel.publish(Twist())
        rospy.sleep(1)


if __name__ == '__main__':
    try:
        while not rospy.is_shutdown():
            xpoints = [1,1,2,2]
            ypoints = [0,1,1,2]
            angles = [90,0,90,0]
            for i in range(len(xpoints)):
                GotoPoint(xpoints[i],ypoints[i],angles[i])
            GotoPoint.shutdowm()
    except:
        rospy.loginfo("shutdown program.") 
